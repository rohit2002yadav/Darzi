
// This file defines the data models for the application, primarily centered around the `Order`.
// These models provide a structured way to handle data received from the backend API.
// They include `fromJson` factory constructors, which are essential for converting
// raw JSON (Map<String, dynamic>) into strongly-typed Dart objects.

class Order {
  // --- Core Identifiers ---
  final String id; // The unique ID for the order, generated by the database.
  final String customerName;
  final String customerPhone;
  final String? customerEmail; // Nullable if the customer signed up with a phone number.
  final String? tailorId; // The ID of the tailor assigned to the order.
  final String tailorName;
  final String? tailorPhone; // The tailor's phone number, useful for the customer to see.
  final String? tailorAddress; // The tailor's shop address.

  // --- Garment & Item Details ---
  final String garmentType; // The main type of garment being made (e.g., "Shirt", "Pant").
  final List<String> items; // A list of items included in the order (often just the garmentType).

  // --- Status & Progress ---
  final String status; // The current status of the order in the workflow (e.g., "PLACED", "STITCHING").

  // --- Financials ---
  final double? totalAmount; // The total cost of the order, may be null initially.

  // --- Logistics & Handover ---
  final String handoverType; // How the fabric is being exchanged ("pickup" or "drop").
  final Map<String, dynamic>? pickup; // A map containing details if it's a pickup (address, time slot).

  // --- Fabric & Measurement Specifics ---
  final bool isTailorProvidingFabric; // A flag indicating who supplies the fabric.
  final Map<String, dynamic>? measurements; // A map of the customer's body measurements (e.g., {"Chest": 42.0}).
  final FabricDetails? fabricDetails; // A nested object with details about the fabric being used.
  final Payment? payment; // A nested object with all payment-related information.

  // --- Timestamps ---
  final DateTime? createdAt; // The timestamp when the order was created.
  final DateTime? updatedAt; // The timestamp when the order was last updated.

  /// A computed property (getter) to safely display the total amount.
  /// It intelligently falls back through different possible sources for the total amount
  /// to avoid null errors and provide a reliable value for the UI.
  double get displayTotalAmount => payment?.totalAmount ?? totalAmount ?? 0.0;

  // The main constructor for creating an `Order` instance.
  Order({
    required this.id,
    required this.customerName,
    required this.customerPhone,
    this.customerEmail,
    this.tailorId,
    required this.tailorName,
    this.tailorPhone,
    this.tailorAddress,
    required this.garmentType,
    required this.items,
    required this.status,
    this.totalAmount,
    required this.handoverType,
    this.pickup,
    required this.isTailorProvidingFabric,
    this.measurements,
    this.fabricDetails,
    this.payment,
    this.createdAt,
    this.updatedAt,
  });

  /// A factory constructor that creates an `Order` instance from a JSON map.
  /// This is the primary way that data from the API is converted into a usable Dart object.
  /// It includes null-aware operators (`??`) to provide default values for missing fields,
  /// preventing the app from crashing if the API response is incomplete.
  factory Order.fromJson(Map<String, dynamic> json) {
    return Order(
      id: json['_id'] ?? json['id'] ?? '', // Handles both MongoDB `_id` and regular `id`.
      customerName: json['customerName'] ?? '',
      customerPhone: json['customerPhone'] ?? '',
      customerEmail: json['customerEmail'],
      tailorId: json['tailorId'],
      tailorName: json['tailorName'] ?? 'Unnamed Tailor',
      tailorPhone: json['tailorPhone'],
      tailorAddress: json['tailorAddress'],
      garmentType: json['garmentType'] ?? '',
      items: List<String>.from(json['items'] ?? []), // Safely converts a dynamic list to a string list.
      status: json['status'] ?? 'PENDING_DEPOSIT',
      totalAmount: (json['totalAmount'] as num?)?.toDouble(), // Safely casts the number to a double.
      handoverType: json['handoverType'] ?? 'drop',
      pickup: json['pickup'] as Map<String, dynamic>?,
      isTailorProvidingFabric: json['isTailorProvidingFabric'] ?? false,
      measurements: json['measurements'] as Map<String, dynamic>?,
      // Recursively call `fromJson` for nested objects.
      fabricDetails: json['fabricDetails'] != null 
          ? FabricDetails.fromJson(json['fabricDetails']) 
          : null,
      payment: json['payment'] != null 
          ? Payment.fromJson(json['payment']) 
          : null,
      // Parse date strings into DateTime objects.
      createdAt: json['createdAt'] != null ? DateTime.parse(json['createdAt']!) : null,
      updatedAt: json['updatedAt'] != null ? DateTime.parse(json['updatedAt']!) : null,
    );
  }

  // Convenience getters to easily access nested pickup details.
  String? get pickupAddress => pickup?['address'];
  String? get pickupTimeSlot => pickup?['timeSlot'];
}

/// A data model representing the payment details of an order.
class Payment {
  final double totalAmount;
  final double depositAmount; // The initial amount required to confirm the order.
  final double paidAmount; // The total amount paid by the customer so far.
  final double remainingAmount;
  final String depositStatus; // e.g., "PENDING", "PAID"
  final String depositMode; // e.g., "CASH", "ONLINE"

  Payment({
    required this.totalAmount,
    required this.depositAmount,
    required this.paidAmount,
    required this.remainingAmount,
    required this.depositStatus,
    required this.depositMode,
  });

  /// Factory constructor to create a `Payment` object from a JSON map.
  factory Payment.fromJson(Map<String, dynamic> json) {
    return Payment(
      totalAmount: (json['totalAmount'] as num?)?.toDouble() ?? 0.0,
      depositAmount: (json['depositAmount'] as num?)?.toDouble() ?? 0.0,
      paidAmount: (json['paidAmount'] as num?)?.toDouble() ?? 0.0,
      remainingAmount: (json['remainingAmount'] as num?)?.toDouble() ?? 0.0,
      depositStatus: json['depositStatus'] ?? 'PENDING',
      depositMode: json['depositMode'] ?? 'CASH',
    );
  }
}

/// A data model representing the details of the fabric used in an order.
/// This class is flexible enough to handle fabric provided by the customer OR the tailor.
class FabricDetails {
  // --- Customer-Provided Fabric Details ---
  final String? type; // e.g., "Cotton", "Silk"
  final String? length; // e.g., "2.5 meters"
  final String? color;
  final String? photoPath; // Local path to the photo the customer uploaded.

  // --- Tailor-Provided Fabric Details ---
  final String? fabricId; // The ID of the fabric from the tailor's inventory.
  final String? name; // The name of the fabric (e.g., "Bombay Rayon Blue Striped").
  final double? pricePerMeter;
  final double? quantity; // The quantity of tailor's fabric used.

  FabricDetails({
    this.type, this.length, this.color, this.photoPath,
    this.fabricId, this.name, this.pricePerMeter, this.quantity
  });

  /// Factory constructor to create a `FabricDetails` object from a JSON map.
  factory FabricDetails.fromJson(Map<String, dynamic> json) {
    return FabricDetails(
      type: json['type'],
      length: json['length'],
      color: json['color'],
      photoPath: json['photoPath'],
      fabricId: json['fabricId'],
      name: json['name'],
      pricePerMeter: (json['pricePerMeter'] as num?)?.toDouble(),
      quantity: (json['quantity'] as num?)?.toDouble(),
    );
  }
}
